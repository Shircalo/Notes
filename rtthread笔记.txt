***********************************************************************************************************
* 创建线程完成时文件为：rtdef.h
*                       main.c 
*                       rtconfig.h
*					    thread.c 
*					    thread.h 
*                       rtservice.h
*                       cpuport.c
*                       rthw.h
* 问题：（1）、ARMCM4.h 文件的来源、
*   （2）、
*   rtthread.c ：
*   /* 初始化线程栈，并返回线程栈指针 */
*	thread->sp = (void *)rt_hw_stack_init( thread->entry,
*                                        thread->parameter,
*                                         (void *)((char *)thread->stack_addr + thread->stack_size -4)	); 
*	cpuport.c ：	
*	/* 线程栈的初始化 */
*	rt_uint8_t *rt_hw_stack_init(void				*tentry,
*	                             void       *parameter,
*								 rt_uint8_t *stack_addr)
*   void* 类型为何作为实参传给 rt_uint8_t* 类型、
***********************************************************************************************************

1、keil5可用的的编译器：CC_ARM、IAR_SYSTEMS_ICC、GNUC

2、inline关键字：	对于一些重复调用的小函数，每次调用都会开辟栈空间，有时开辟函数栈
				所花的时间大于函数执行的时间，此时可用inline修饰函数。
					inline的效果类似于带参的宏，有着替换的效果，缺点是会增大代码量，
				占用更多的内存。
					仅适用于简短的代码。
				参考：https://blog.csdn.net/zqixiao_09/article/details/50877383
				
3、align、 __align、 pragma pack(n)、 __attribute__((aligned(m)))、 __attribute__ ((__packed__))
					参考：https://blog.csdn.net/minyuanxiani/article/details/82626919
						  https://www.cnblogs.com/xidongs/p/5655440.html
				字节对齐：http://c.biancheng.net/view/147.html	
	
4、#define ALIGN(size, align) ((size + align - 1) & (~(align - 1)))      
//这个宏的功能是整数提升，即将size提升为align定义的整数的倍数。
例如：align=8,size=7，则这条宏运行的结果是8；align=8,size=13，则这条宏运行的结果是16。

   RT_ALIGN_DOWN(size, align)
   
5、在双向链表头部插入一个节点：对于给定的两个节点，先连接没有给定的一个，再链接给定的一个。

6、数组和栈的生长方向：https://blog.csdn.net/qq_35218635/article/details/79198127

7、字节对齐：	为了满足计算机读写内存的要求，对基本数据类型的合法地址作出一些限制，
即它的地址必须是2，4或8的倍数。那么就要求各种数据类型按照一定的规则在空间上排列，这就是对齐。
			    参考：https://mp.weixin.qq.com/s/VK_Tzf5qdVhvnvuljZF1wg

8、/* 让stk指针向下8字节对齐 ，先将stk转换为数，再对其进行计算
   最后强转为指针 */
	stk  = (rt_uint8_t *)RT_ALIGN_DOWN((rt_uint32_t)stk, 8);
	
9、void \ void *
				void *：任何类型的指针都可以直接赋值给它，无需进行强制类型转换
				（“无类型”可以包容“有类型”，而“有类型”则不能包容“无类型”）
*********************************************************************************************************
**增加文件 context_rvds.s 
* rt_interrupt_to_thread 与 rt_interrupt_from_thread 是供线程切换时寄存器实用的
*
*********************************************************************************************************	

10、注意PendSV

11、立即寻址方式：		立即寻址方式所提供的操作数紧跟在操作码的后面，与操作码一起放在指令代码段中。立即数可以是8位无符号整数或16位无符号整数，
					但不可以是小数。如果是16位数，则低位字节存放在低地址中，高位字节存放在高地址中。
 
12、将一个立即数存放到内存的操作：（1）在a寄存器中放内存地址
                                   （2）在b寄存器中放立即数
								     （3）将b寄存器的值传给a寄存器
						
13、LDR:	https://blog.csdn.net/tanyouliang/article/details/6767011

14、CPSID 与 CPSIE :用于开关总中断
					https://blog.csdn.net/lixiaojie1012/article/details/39480599

15、r1~r12、r13(SP)、r14(LR)、r15(PC) :
										https://blog.csdn.net/bitowang/article/details/8488251

16、ARM寄存器：
				https://blog.csdn.net/Sandeldeng/article/details/52954781
					https://blog.csdn.net/wh8_2011/article/details/53195320
					

				
17、ORR指令：	ORR 指令的格式为： 
				ORR{条件}{S} 目的寄存器，操作数 1，操作数 2
				ORR 指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。操作数 1
				应是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于设置操作数 1 的某些位。 
				指令示例： 
				ORR   R0，R0，＃3             ； 该指令设置R0的0、1位，其余位保持不变。
            https://blog.csdn.net/w282529350/article/details/8781086

18、无条件跳转指令
	跳转指令分为无条件跳转和有条件跳转两大类。无条件跳转类指令非常简单，常见的就四种形式。

	B Label ;跳转到Label处对应的地址, 无条件跳转指令

	BX reg ;跳转到由寄存器reg给出的地址, 无条件跳转指令

	BL Label ;跳转到Label对应的地址，并且把跳转前的下条指令地址保存到LR

	BLX reg ;跳转到由寄存器reg给出的地址，并根据REG的LSB切换处理器状态，还要把转移前的下条指令地址保存到LR

	https://blog.csdn.net/u010893262/article/details/52808639

19、ARM指令格式：
					https://blog.csdn.net/ftx2540993425/article/details/29926075
***************************************************************************************************************************************
*                                      临界段的保护
*
***************************************************************************************************************************************

20、临界段：不能被中断的代码段，此代码常常是对全局变量的操作
	保护：为了使代码不被中断，关闭所有中断
	Cortex-M 内核中有3个中断屏蔽寄存器，CPS指令可以操作 PRIMASK 和 FAULTMASK ，从而快速关闭中断

	关闭中断-执行临界段-打开中断      //过程结束后 PRIMASK 的值不变












